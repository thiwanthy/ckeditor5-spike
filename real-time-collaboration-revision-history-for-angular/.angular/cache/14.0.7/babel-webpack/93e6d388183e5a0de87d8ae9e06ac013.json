{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties.js';\nimport Watchdog from './watchdog.js';\nimport { throttle, cloneDeepWith, isElement } from 'lodash-es';\n/**\n * A watchdog for CKEditor 5 editors.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class EditorWatchdog extends Watchdog {\n  /**\n   * @param Editor The editor class.\n   * @param watchdogConfig The watchdog plugin configuration.\n   */\n  constructor(Editor, watchdogConfig = {}) {\n    super(watchdogConfig);\n    /**\n     * The current editor instance.\n     */\n    this._editor = null;\n    /**\n     * A promise associated with the life cycle of the editor (creation or destruction processes).\n     *\n     * It is used to prevent the initialization of the editor if the previous instance has not been destroyed yet,\n     * and conversely, to prevent the destruction of the editor if it has not been initialized.\n     */\n    this._lifecyclePromise = null;\n    /**\n     * Specifies whether the editor was initialized using document data (`true`) or HTML elements (`false`).\n     */\n    this._initUsingData = true;\n    /**\n     * The latest record of the editor editable elements. Used to restart the editor.\n     */\n    this._editables = {};\n    // this._editorClass = Editor;\n    this._throttledSave = throttle(this._save.bind(this), typeof watchdogConfig.saveInterval === 'number' ? watchdogConfig.saveInterval : 5000);\n    // Set default creator and destructor functions:\n    if (Editor) {\n      this._creator = (elementOrData, config) => Editor.create(elementOrData, config);\n    }\n    this._destructor = editor => editor.destroy();\n  }\n  /**\n   * The current editor instance.\n   */\n  get editor() {\n    return this._editor;\n  }\n  /**\n   * @internal\n   */\n  get _item() {\n    return this._editor;\n  }\n  /**\n   * Sets the function that is responsible for the editor creation.\n   * It expects a function that should return a promise.\n   *\n   * ```ts\n   * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );\n   * ```\n   */\n  setCreator(creator) {\n    this._creator = creator;\n  }\n  /**\n   * Sets the function that is responsible for the editor destruction.\n   * Overrides the default destruction function, which destroys only the editor instance.\n   * It expects a function that should return a promise or `undefined`.\n   *\n   * ```ts\n   * watchdog.setDestructor( editor => {\n   * \t// Do something before the editor is destroyed.\n   *\n   * \treturn editor\n   * \t\t.destroy()\n   * \t\t.then( () => {\n   * \t\t\t// Do something after the editor is destroyed.\n   * \t\t} );\n   * } );\n   * ```\n   */\n  setDestructor(destructor) {\n    this._destructor = destructor;\n  }\n  /**\n   * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes\n   * the state to `initializing`.\n   *\n   * @fires restart\n   */\n  _restart() {\n    return Promise.resolve().then(() => {\n      this.state = 'initializing';\n      this._fire('stateChange');\n      return this._destroy();\n    }).catch(err => {\n      console.error('An error happened during the editor destroying.', err);\n    }).then(() => {\n      // Pre-process some data from the original editor config.\n      // Our goal here is to make sure that the restarted editor will be reinitialized with correct set of roots.\n      // We are not interested in any data set in config or in `.create()` first parameter. It will be replaced anyway.\n      // But we need to set them correctly to make sure that proper roots are created.\n      //\n      // Since a different set of roots will be created, `lazyRoots` and `rootsAttributes` properties must be managed too.\n      // Keys are root names, values are ''. Used when the editor was initialized by setting the first parameter to document data.\n      const existingRoots = {};\n      // Keeps lazy roots. They may be different when compared to initial config if some of the roots were loaded.\n      const lazyRoots = [];\n      // Roots attributes from the old config. Will be referred when setting new attributes.\n      const oldRootsAttributes = this._config.rootsAttributes || {};\n      // New attributes to be set. Is filled only for roots that still exist in the document.\n      const rootsAttributes = {};\n      // Traverse through the roots saved when the editor crashed and set up the discussed values.\n      for (const [rootName, rootData] of Object.entries(this._data.roots)) {\n        if (rootData.isLoaded) {\n          existingRoots[rootName] = '';\n          rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};\n        } else {\n          lazyRoots.push(rootName);\n        }\n      }\n      const updatedConfig = {\n        ...this._config,\n        extraPlugins: this._config.extraPlugins || [],\n        lazyRoots,\n        rootsAttributes,\n        _watchdogInitialData: this._data\n      };\n      // Delete `initialData` as it is not needed. Data will be set by the watchdog based on `_watchdogInitialData`.\n      // First parameter of the editor `.create()` will be used to set up initial roots.\n      delete updatedConfig.initialData;\n      updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);\n      if (this._initUsingData) {\n        return this.create(existingRoots, updatedConfig, updatedConfig.context);\n      } else {\n        // Set correct editables to make sure that proper roots are created and linked with DOM elements.\n        // No need to set initial data, as it would be discarded anyway.\n        //\n        // If one element was initially set in `elementOrData`, then use that original element to restart the editor.\n        // This is for compatibility purposes with single-root editor types.\n        if (isElement(this._elementOrData)) {\n          return this.create(this._elementOrData, updatedConfig, updatedConfig.context);\n        } else {\n          return this.create(this._editables, updatedConfig, updatedConfig.context);\n        }\n      }\n    }).then(() => {\n      this._fire('restart');\n    });\n  }\n  /**\n   * Creates the editor instance and keeps it running, using the defined creator and destructor.\n   *\n   * @param elementOrData The editor source element or the editor data.\n   * @param config The editor configuration.\n   * @param context A context for the editor.\n   */\n  create(elementOrData = this._elementOrData, config = this._config, context) {\n    this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {\n      super._startErrorHandling();\n      this._elementOrData = elementOrData;\n      // Use document data in the first parameter of the editor `.create()` call only if it was used like this originally.\n      // Use document data if a string or object with strings was passed.\n      this._initUsingData = typeof elementOrData == 'string' || Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == 'string';\n      // Clone configuration because it might be shared within multiple watchdog instances. Otherwise,\n      // when an error occurs in one of these editors, the watchdog will restart all of them.\n      this._config = this._cloneEditorConfiguration(config) || {};\n      this._config.context = context;\n      return this._creator(elementOrData, this._config);\n    }).then(editor => {\n      this._editor = editor;\n      editor.model.document.on('change:data', this._throttledSave);\n      this._lastDocumentVersion = editor.model.document.version;\n      this._data = this._getData();\n      if (!this._initUsingData) {\n        this._editables = this._getEditables();\n      }\n      this.state = 'ready';\n      this._fire('stateChange');\n    }).finally(() => {\n      this._lifecyclePromise = null;\n    });\n    return this._lifecyclePromise;\n  }\n  /**\n   * Destroys the watchdog and the current editor instance. It fires the callback\n   * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.\n   * It also sets the state to `destroyed`.\n   */\n  destroy() {\n    this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {\n      this.state = 'destroyed';\n      this._fire('stateChange');\n      super.destroy();\n      return this._destroy();\n    }).finally(() => {\n      this._lifecyclePromise = null;\n    });\n    return this._lifecyclePromise;\n  }\n  _destroy() {\n    return Promise.resolve().then(() => {\n      this._stopErrorHandling();\n      this._throttledSave.cancel();\n      const editor = this._editor;\n      this._editor = null;\n      // Remove the `change:data` listener before destroying the editor.\n      // Incorrectly written plugins may trigger firing `change:data` events during the editor destruction phase\n      // causing the watchdog to call `editor.getData()` when some parts of editor are already destroyed.\n      editor.model.document.off('change:data', this._throttledSave);\n      return this._destructor(editor);\n    });\n  }\n  /**\n   * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at\n   * the moment of the crash.\n   */\n  _save() {\n    const version = this._editor.model.document.version;\n    try {\n      this._data = this._getData();\n      if (!this._initUsingData) {\n        this._editables = this._getEditables();\n      }\n      this._lastDocumentVersion = version;\n    } catch (err) {\n      console.error(err, 'An error happened during restoring editor data. ' + 'Editor will be restored from the previously saved data.');\n    }\n  }\n  /**\n   * @internal\n   */\n  _setExcludedProperties(props) {\n    this._excludedProps = props;\n  }\n  /**\n   * Gets all data that is required to reinitialize editor instance.\n   */\n  _getData() {\n    const editor = this._editor;\n    const roots = editor.model.document.roots.filter(root => root.isAttached() && root.rootName != '$graveyard');\n    const {\n      plugins\n    } = editor;\n    // `as any` to avoid linking from external private repo.\n    const commentsRepository = plugins.has('CommentsRepository') && plugins.get('CommentsRepository');\n    const trackChanges = plugins.has('TrackChanges') && plugins.get('TrackChanges');\n    const data = {\n      roots: {},\n      markers: {},\n      commentThreads: JSON.stringify([]),\n      suggestions: JSON.stringify([])\n    };\n    roots.forEach(root => {\n      data.roots[root.rootName] = {\n        content: JSON.stringify(Array.from(root.getChildren())),\n        attributes: JSON.stringify(Array.from(root.getAttributes())),\n        isLoaded: root._isLoaded\n      };\n    });\n    for (const marker of editor.model.markers) {\n      if (!marker._affectsData) {\n        continue;\n      }\n      data.markers[marker.name] = {\n        rangeJSON: marker.getRange().toJSON(),\n        usingOperation: marker._managedUsingOperations,\n        affectsData: marker._affectsData\n      };\n    }\n    if (commentsRepository) {\n      data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({\n        toJSON: true,\n        skipNotAttached: true\n      }));\n    }\n    if (trackChanges) {\n      data.suggestions = JSON.stringify(trackChanges.getSuggestions({\n        toJSON: true,\n        skipNotAttached: true\n      }));\n    }\n    return data;\n  }\n  /**\n   * For each attached model root, returns its HTML editable element (if available).\n   */\n  _getEditables() {\n    const editables = {};\n    for (const rootName of this.editor.model.document.getRootNames()) {\n      const editable = this.editor.ui.getEditableElement(rootName);\n      if (editable) {\n        editables[rootName] = editable;\n      }\n    }\n    return editables;\n  }\n  /**\n   * Traverses the error context and the current editor to find out whether these structures are connected\n   * to each other via properties.\n   *\n   * @internal\n   */\n  _isErrorComingFromThisItem(error) {\n    return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);\n  }\n  /**\n   * Clones the editor configuration.\n   */\n  _cloneEditorConfiguration(config) {\n    return cloneDeepWith(config, (value, key) => {\n      // Leave DOM references.\n      if (isElement(value)) {\n        return value;\n      }\n      if (key === 'context') {\n        return value;\n      }\n    });\n  }\n}\n/**\n * Internal plugin that is used to stop the default editor initialization and restoring the editor state\n * based on the `editor.config._watchdogInitialData` data.\n */\nclass EditorWatchdogInitPlugin {\n  constructor(editor) {\n    this.editor = editor;\n    this._data = editor.config.get('_watchdogInitialData');\n  }\n  /**\n   * @inheritDoc\n   */\n  init() {\n    // Stops the default editor initialization and use the saved data to restore the editor state.\n    // Some of data could not be initialize as a config properties. It is important to keep the data\n    // in the same form as it was before the restarting.\n    this.editor.data.on('init', evt => {\n      evt.stop();\n      this.editor.model.enqueueChange({\n        isUndoable: false\n      }, writer => {\n        this._restoreCollaborationData();\n        this._restoreEditorData(writer);\n      });\n      this.editor.data.fire('ready');\n      // Keep priority `'high' - 1` to be sure that RTC initialization will be first.\n    }, {\n      priority: 1000 - 1\n    });\n  }\n  /**\n   * Creates a model node (element or text) based on provided JSON.\n   */\n  _createNode(writer, jsonNode) {\n    if ('name' in jsonNode) {\n      // If child has name property, it is an Element.\n      const element = writer.createElement(jsonNode.name, jsonNode.attributes);\n      if (jsonNode.children) {\n        for (const child of jsonNode.children) {\n          element._appendChild(this._createNode(writer, child));\n        }\n      }\n      return element;\n    } else {\n      // Otherwise, it is a Text node.\n      return writer.createText(jsonNode.data, jsonNode.attributes);\n    }\n  }\n  /**\n   * Restores the editor by setting the document data, roots attributes and markers.\n   */\n  _restoreEditorData(writer) {\n    const editor = this.editor;\n    Object.entries(this._data.roots).forEach(([rootName, {\n      content,\n      attributes\n    }]) => {\n      const parsedNodes = JSON.parse(content);\n      const parsedAttributes = JSON.parse(attributes);\n      const rootElement = editor.model.document.getRoot(rootName);\n      for (const [key, value] of parsedAttributes) {\n        writer.setAttribute(key, value, rootElement);\n      }\n      for (const child of parsedNodes) {\n        const node = this._createNode(writer, child);\n        writer.insert(node, rootElement, 'end');\n      }\n    });\n    Object.entries(this._data.markers).forEach(([markerName, markerOptions]) => {\n      const {\n        document\n      } = editor.model;\n      const {\n        rangeJSON: {\n          start,\n          end\n        },\n        ...options\n      } = markerOptions;\n      const root = document.getRoot(start.root);\n      const startPosition = writer.createPositionFromPath(root, start.path, start.stickiness);\n      const endPosition = writer.createPositionFromPath(root, end.path, end.stickiness);\n      const range = writer.createRange(startPosition, endPosition);\n      writer.addMarker(markerName, {\n        range,\n        ...options\n      });\n    });\n  }\n  /**\n   * Restores the editor collaboration data - comment threads and suggestions.\n   */\n  _restoreCollaborationData() {\n    // `as any` to avoid linking from external private repo.\n    const parsedCommentThreads = JSON.parse(this._data.commentThreads);\n    const parsedSuggestions = JSON.parse(this._data.suggestions);\n    parsedCommentThreads.forEach(commentThreadData => {\n      const channelId = this.editor.config.get('collaboration.channelId');\n      const commentsRepository = this.editor.plugins.get('CommentsRepository');\n      if (commentsRepository.hasCommentThread(commentThreadData.threadId)) {\n        const commentThread = commentsRepository.getCommentThread(commentThreadData.threadId);\n        commentThread.remove();\n      }\n      commentsRepository.addCommentThread({\n        channelId,\n        ...commentThreadData\n      });\n    });\n    parsedSuggestions.forEach(suggestionData => {\n      const trackChangesEditing = this.editor.plugins.get('TrackChangesEditing');\n      if (trackChangesEditing.hasSuggestion(suggestionData.id)) {\n        const suggestion = trackChangesEditing.getSuggestion(suggestionData.id);\n        suggestion.attributes = suggestionData.attributes;\n      } else {\n        trackChangesEditing.addSuggestionData(suggestionData);\n      }\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}
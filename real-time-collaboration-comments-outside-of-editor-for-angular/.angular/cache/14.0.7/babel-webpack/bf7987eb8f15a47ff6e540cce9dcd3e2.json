{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Watchdog from './watchdog.js';\nimport EditorWatchdog from './editorwatchdog.js';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties.js';\nimport getSubNodes from './utils/getsubnodes.js';\nconst mainQueueId = Symbol('MainQueueId');\n/**\n * A watchdog for the {@link module:core/context~Context} class.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class ContextWatchdog extends Watchdog {\n  /**\n   * The context watchdog class constructor.\n   *\n   * ```ts\n   * const watchdog = new ContextWatchdog( Context );\n   *\n   * await watchdog.create( contextConfiguration );\n   *\n   * await watchdog.add( item );\n   * ```\n   *\n   * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\n   *\n   * @param Context The {@link module:core/context~Context} class.\n   * @param watchdogConfig The watchdog configuration.\n   */\n  constructor(Context, watchdogConfig = {}) {\n    super(watchdogConfig);\n    /**\n     * A map of internal watchdogs for added items.\n     */\n    this._watchdogs = new Map();\n    /**\n     * The current context instance.\n     */\n    this._context = null;\n    /**\n     * Context properties (nodes/references) that are gathered during the initial context creation\n     * and are used to distinguish the origin of an error.\n     */\n    this._contextProps = new Set();\n    /**\n     * An action queue, which is used to handle async functions queuing.\n     */\n    this._actionQueues = new ActionQueues();\n    this._watchdogConfig = watchdogConfig;\n    // Default creator and destructor.\n    this._creator = contextConfig => Context.create(contextConfig);\n    this._destructor = context => context.destroy();\n    this._actionQueues.onEmpty(() => {\n      if (this.state === 'initializing') {\n        this.state = 'ready';\n        this._fire('stateChange');\n      }\n    });\n  }\n  /**\n   * Sets the function that is responsible for the context creation.\n   * It expects a function that should return a promise (or `undefined`).\n   *\n   * ```ts\n   * watchdog.setCreator( config => Context.create( config ) );\n   * ```\n   */\n  setCreator(creator) {\n    this._creator = creator;\n  }\n  /**\n   * Sets the function that is responsible for the context destruction.\n   * Overrides the default destruction function, which destroys only the context instance.\n   * It expects a function that should return a promise (or `undefined`).\n   *\n   * ```ts\n   * watchdog.setDestructor( context => {\n   * \t// Do something before the context is destroyed.\n   *\n   * \treturn context\n   * \t\t.destroy()\n   * \t\t.then( () => {\n   * \t\t\t// Do something after the context is destroyed.\n   * \t\t} );\n   * } );\n   * ```\n   */\n  setDestructor(destructor) {\n    this._destructor = destructor;\n  }\n  /**\n   * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\n   * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\n   */\n  get context() {\n    return this._context;\n  }\n  /**\n   * Initializes the context watchdog. Once it is created, the watchdog takes care about\n   * recreating the context and the provided items, and starts the error handling mechanism.\n   *\n   * ```ts\n   * await watchdog.create( {\n   * \tplugins: []\n   * } );\n   * ```\n   *\n   * @param contextConfig The context configuration. See {@link module:core/context~Context}.\n   */\n  create(contextConfig = {}) {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this._contextConfig = contextConfig;\n      return this._create();\n    });\n  }\n  /**\n   * Returns an item instance with the given `itemId`.\n   *\n   * ```ts\n   * const editor1 = watchdog.getItem( 'editor1' );\n   * ```\n   *\n   * @param itemId The item ID.\n   * @returns The item instance or `undefined` if an item with a given ID has not been found.\n   */\n  getItem(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n    return watchdog._item;\n  }\n  /**\n   * Gets the state of the given item. See {@link #state} for a list of available states.\n   *\n   * ```ts\n   * const editor1State = watchdog.getItemState( 'editor1' );\n   * ```\n   *\n   * @param itemId Item ID.\n   * @returns The state of the item.\n   */\n  getItemState(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n    return watchdog.state;\n  }\n  /**\n   * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\n   *\n   * Items can be passed together as an array of objects:\n   *\n   * ```ts\n   * await watchdog.add( [ {\n   * \tid: 'editor1',\n   * \ttype: 'editor',\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\n   * \tconfig: {\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n   * \t},\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n   * } ] );\n   * ```\n   *\n   * Or one by one as objects:\n   *\n   * ```ts\n   * await watchdog.add( {\n   * \tid: 'editor1',\n   * \ttype: 'editor',\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\n   * \tconfig: {\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n   * \t},\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n   * ] );\n   * ```\n   *\n   * Then an instance can be retrieved using the {@link #getItem} method:\n   *\n   * ```ts\n   * const editor1 = watchdog.getItem( 'editor1' );\n   * ```\n   *\n   * Note that this method can be called multiple times, but for performance reasons it is better\n   * to pass all items together.\n   *\n   * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\n   */\n  add(itemConfigurationOrItemConfigurations) {\n    const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n    return Promise.all(itemConfigurations.map(item => {\n      return this._actionQueues.enqueue(item.id, () => {\n        if (this.state === 'destroyed') {\n          throw new Error('Cannot add items to destroyed watchdog.');\n        }\n        if (!this._context) {\n          throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n        }\n        let watchdog;\n        if (this._watchdogs.has(item.id)) {\n          throw new Error(`Item with the given id is already added: '${item.id}'.`);\n        }\n        if (item.type === 'editor') {\n          watchdog = new EditorWatchdog(null, this._watchdogConfig);\n          watchdog.setCreator(item.creator);\n          watchdog._setExcludedProperties(this._contextProps);\n          if (item.destructor) {\n            watchdog.setDestructor(item.destructor);\n          }\n          this._watchdogs.set(item.id, watchdog);\n          // Enqueue the internal watchdog errors within the main queue.\n          // And propagate the internal `error` events as `itemError` event.\n          watchdog.on('error', (evt, {\n            error,\n            causesRestart\n          }) => {\n            this._fire('itemError', {\n              itemId: item.id,\n              error\n            });\n            // Do not enqueue the item restart action if the item will not restart.\n            if (!causesRestart) {\n              return;\n            }\n            this._actionQueues.enqueue(item.id, () => new Promise(res => {\n              const rethrowRestartEventOnce = () => {\n                watchdog.off('restart', rethrowRestartEventOnce);\n                this._fire('itemRestart', {\n                  itemId: item.id\n                });\n                res();\n              };\n              watchdog.on('restart', rethrowRestartEventOnce);\n            }));\n          });\n          return watchdog.create(item.sourceElementOrData, item.config, this._context);\n        } else {\n          throw new Error(`Not supported item type: '${item.type}'.`);\n        }\n      });\n    }));\n  }\n  /**\n   * Removes and destroys item(s) with given ID(s).\n   *\n   * ```ts\n   * await watchdog.remove( 'editor1' );\n   * ```\n   *\n   * Or\n   *\n   * ```ts\n   * await watchdog.remove( [ 'editor1', 'editor2' ] );\n   * ```\n   *\n   * @param itemIdOrItemIds Item ID or an array of item IDs.\n   */\n  remove(itemIdOrItemIds) {\n    const itemIds = toArray(itemIdOrItemIds);\n    return Promise.all(itemIds.map(itemId => {\n      return this._actionQueues.enqueue(itemId, () => {\n        const watchdog = this._getWatchdog(itemId);\n        this._watchdogs.delete(itemId);\n        return watchdog.destroy();\n      });\n    }));\n  }\n  /**\n   * Destroys the context watchdog and all added items.\n   * Once the context watchdog is destroyed, new items cannot be added.\n   *\n   * ```ts\n   * await watchdog.destroy();\n   * ```\n   */\n  destroy() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'destroyed';\n      this._fire('stateChange');\n      super.destroy();\n      return this._destroy();\n    });\n  }\n  /**\n   * Restarts the context watchdog.\n   */\n  _restart() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'initializing';\n      this._fire('stateChange');\n      return this._destroy().catch(err => {\n        console.error('An error happened during destroying the context or items.', err);\n      }).then(() => this._create()).then(() => this._fire('restart'));\n    });\n  }\n  /**\n   * Initializes the context watchdog.\n   */\n  _create() {\n    return Promise.resolve().then(() => {\n      this._startErrorHandling();\n      return this._creator(this._contextConfig);\n    }).then(context => {\n      this._context = context;\n      this._contextProps = getSubNodes(this._context);\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => {\n        watchdog._setExcludedProperties(this._contextProps);\n        return watchdog.create(undefined, undefined, this._context);\n      }));\n    });\n  }\n  /**\n   * Destroys the context instance and all added items.\n   */\n  _destroy() {\n    return Promise.resolve().then(() => {\n      this._stopErrorHandling();\n      const context = this._context;\n      this._context = null;\n      this._contextProps = new Set();\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => watchdog.destroy()))\n      // Context destructor destroys each editor.\n      .then(() => this._destructor(context));\n    });\n  }\n  /**\n   * Returns the watchdog for a given item ID.\n   *\n   * @param itemId Item ID.\n   */\n  _getWatchdog(itemId) {\n    const watchdog = this._watchdogs.get(itemId);\n    if (!watchdog) {\n      throw new Error(`Item with the given id was not registered: ${itemId}.`);\n    }\n    return watchdog;\n  }\n  /**\n   * Checks whether an error comes from the context instance and not from the item instances.\n   *\n   * @internal\n   */\n  _isErrorComingFromThisItem(error) {\n    for (const watchdog of this._watchdogs.values()) {\n      if (watchdog._isErrorComingFromThisItem(error)) {\n        return false;\n      }\n    }\n    return areConnectedThroughProperties(this._context, error.context);\n  }\n}\n/**\n * Manager of action queues that allows queuing async functions.\n */\nclass ActionQueues {\n  constructor() {\n    this._onEmptyCallbacks = [];\n    this._queues = new Map();\n    this._activeActions = 0;\n  }\n  /**\n   * Used to register callbacks that will be run when the queue becomes empty.\n   *\n   * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\n   */\n  onEmpty(onEmptyCallback) {\n    this._onEmptyCallbacks.push(onEmptyCallback);\n  }\n  /**\n   * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\n   *\n   * @param queueId The action queue ID.\n   * @param action A function that should be enqueued.\n   */\n  enqueue(queueId, action) {\n    const isMainAction = queueId === mainQueueId;\n    this._activeActions++;\n    if (!this._queues.get(queueId)) {\n      this._queues.set(queueId, Promise.resolve());\n    }\n    // List all sources of actions that the current action needs to await for.\n    // For the main action wait for all other actions.\n    // For the item action wait only for the item queue and the main queue.\n    const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n    const queueWithAction = awaitedActions.then(action);\n    // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n    const nonErrorQueue = queueWithAction.catch(() => {});\n    this._queues.set(queueId, nonErrorQueue);\n    return queueWithAction.finally(() => {\n      this._activeActions--;\n      if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n        this._onEmptyCallbacks.forEach(cb => cb());\n      }\n    });\n  }\n}\n/**\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\n *\n * @param elementOrArray The value to transform to an array.\n * @returns An array created from data.\n */\nfunction toArray(elementOrArray) {\n  return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}","map":null,"metadata":{},"sourceType":"module"}